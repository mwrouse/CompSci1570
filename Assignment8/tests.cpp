/* 
	Program......: Assignment 08
	File.........: tests.cpp
	Student......: Michael Rouse 
	Student ID...: 12442296
	Class........: Comp Sci 1570 Section D
	Instructor...: Fletcher
	Date.........: 04/06/2015
	Description..: Functions and variables for Test 1 and Test 2
*/
#include "tests.h"

/*
	Name.........: Cow Birth
	Author.......: Michael Rouse
	Syntax.......: cowBirth(cows[], NUMBER_OF_COWS, DEAD_COWS);
	Parameters...: cows[] - an array of the bovine type 
								 NUMBER_OF_COWS - The size of the cows[] array (number of cows to generate)
								 DEAD_COWS - true if generating the dead cow info 
	Return.......: N/A
	Description..: Will fill an array with bovine (name, dental records, and a DNA sample)
*/
void cowBirth(bovine cows[], const int NUMBER_OF_COWS, const bool DEAD_COWS)
{
	// Variables 
	string cowNames[] = {"Sir Loin", "Leaky Milk", "Moon Rider", "Creamer", "Milky Mike"};
	
	// Loop to generate the cows 
	for (int i = 0; i < NUMBER_OF_COWS; i++)
	{
		// Setup each cow in the array 
		cows[i].name = cowNames[i];
		
		if (DEAD_COWS)
			generateDNA(cows[i].DNA, DEAD_DNA_SIZE, true);
		else
			generateDNA(cows[i].DNA, DNA_SIZE);
			
		generateDental(cows[i].dental, DENTAL_SIZE);		
	}
	
	return;
}

/*
	Name.........: Perform Tests
	Author.......: Michael Rouse
	Syntax.......: performTests();
	Parameters...: N/A
	Return.......: N/A
	Description..: Will perform the task of Test 1
*/
void performTests(bovine deadCows[], bovine missingCows[])
{
	for (int i = 0; i < NUMBER_OF_DEAD_COWS; i++)
	{
		// Compare every dead cow (i) to each missing cow (j)
		for (int j = 0; j < NUMBER_OF_MISSING_COWS; j++)
		{
			// Check the dead cow's DNA to all the recorded cows
			if (!checkDNAMatch(missingCows[j].DNA, deadCows[i].DNA, missingCows[j].name))
				// No match found, do test 2
				checkDentalMatch(missingCows[j].dental, deadCows[i].dental, missingCows[j].name);
			
		}
	}
	
	return;
}

/*
	Name.........: Generate DNA
	Author.......: Michael Rouse
	Syntax.......: generateDNA(DNA_SIZE[, MISSING_STRANDS]);
	Parameters...: DNA_SIZE - The size of the DNA strand to cread
								 MISSING_STRANDS - If true then the function will create missing strands at a 2% chance (default: false)
	Return.......: string - the DNA string that has been generated
	Description..: Will create a random strand of DNA letters for use in the program
*/
void generateDNA(char DNA[], const int DNA_SIZE, const bool MISSING_STRANDS)
{
	// Constants
	const double A_PERCENT = .35;
	const double C_PERCENT = .30;
	const double T_PERCENT = .20;
	const double G_PERCENT = .15;
	
	const int A_MAX = getPercentage(DNA_SIZE, A_PERCENT); // ~35% of total DNA
	const int C_MAX = getPercentage(DNA_SIZE, C_PERCENT); // ~30% of total DNA
	const int T_MAX = getPercentage(DNA_SIZE, T_PERCENT);	// ~20% of total DNA
	const int G_MAX = getPercentage(DNA_SIZE, G_PERCENT); // ~15% of total DNA
	
	bool valid = false;
	
	int number;
	
	// Strand counters and array of possible strands
	// [0][0] - A Count 				[0][1] - Max A				|	strands[0] - A
	// [1][0] - C Count					[1][1] - Mac C 				|	strands[1] - C
	// [2][0] - T Count 				[2][1] - Max T				|	strands[2] - T
	// [3][0] - G Count 				[3][1] - Max G				|	strands[3] - G
	// [4][0] - Unknown Count 	[4][1] - Max Unknown	|	strands[4] - Unknown
	int strandCount[][2] = {{0, A_MAX}, {0, C_MAX}, {0, T_MAX}, {0, G_MAX}, {0, DNA_SIZE}}; // {{strand_count, strand_limit}, ...}
	char strands[] = {'A', 'C', 'T', 'G', '-'}; // All possible strands
	
	for (int i = 0; i < DNA_SIZE; i++)
	{
		valid = false;

		// Loop until a valid and a valid DNA strand is generated
		do
		{
			// Generate random number (0-3)
			number = random(0, 3);
			
			// Attempt to generate an unknown strand if needed
			if ((random(1, 100) <= 2) && MISSING_STRANDS)
				// Create an unknown strand
				number = 4;
			
			// Check to see if the strand has not reached it's limit; place it if it hasn't
			if (strandCount[number][0] < strandCount[number][1])
			{
				DNA[i] = strands[number];
				strandCount[number][0]++;
				valid = true;
			}
			
		} while (!valid);
	}

	// Set the null-termination for the ntca
	DNA[DNA_SIZE] = '\0';	
	
	return;
}

/*
	Name.........: Check DNA Match
	Author.......: Michael Rouse
	Syntax.......: checkDNAMatch(missingDNA, foundDNA);
	Parameters...: missingDNA - the DNA generated by the generateDNA() function
								 foundDNA - the DNA found at the crime scene (also by the generateDNA()) function
	Return.......: true - foundDNA matches at least 90% with a substring of missingDNA
								 false - foundDNA has no match above 90%
	Description..: Will check to see if foundDNA matches with any substring inside of missingDNA of at-least 90% matches
*/
bool checkDNAMatch(char missingDNA[], char foundDNA[], string cowName)
{
	// Constants
	const double MINIMUM_PERCENTAGE = .90;
	
	const int GENERATED_DNA_LENGTH = strlen(missingDNA);
	const int FOUND_DNA_LENGTH = strlen(missingDNA); // Set the FOUND_DNA_LENGTH to the DNA with the smaller amount of strands
	const int MINIMUM_MATCH = ((static_cast<double>(FOUND_DNA_LENGTH) * MINIMUM_PERCENTAGE) + .5); // the number of characters for 90% of the string to make a match
	
	// Variables
	bool stringMatch = false;
	
	int matches; // The number of matches in the current substring 
	int matchLength = 0; // The number of characters that match
	
	// Loop through each of the strands, except the last 16
	for (int i = 0; i <= (GENERATED_DNA_LENGTH - FOUND_DNA_LENGTH); i++)
	{
		matches = 0;
		
		// Check ahead 16 strands (instead of using substrings
		for (int j = 0; j < FOUND_DNA_LENGTH; j++)
		{
			// Make sure the strand is not unknown
			if (foundDNA[j] != '-')
			{	
				// Check if the strand is a match for the strand in missing DNA
				if (foundDNA[j] == missingDNA[i+j])
					matches++; // Increase the match counter
			}
		}
		
		// Check if this match has more matches than the others
		if (matches >= MINIMUM_MATCH && matches > matchLength)
			matchLength = matches;

	}
	
	// Output results
	cout << "\n\n\n";
	cout << "|===================================|\n";
	cout << "|            TEST 1 RESULTS         |\n";
	cout << "|===================================|\n";
	if (matchLength < MINIMUM_MATCH)
	{
		// No Match found
		cout << "Result......: No Match Found\n";
		cout << "Cow Name....: " << cowName << "\n";
		cout << "Strand......: " << missingDNA << "\n";
		
	}else{
		// Match Found
		cout << "Result......: Match Found!\n";
		cout << "Cow Name....: " << cowName << "\n";
		cout << "Accuracy....: " << ((static_cast<double>(matchLength) + .5) / FOUND_DNA_LENGTH) * 100 << "%\n";
		cout << "Strand......: " << missingDNA << "\n";
		cout << "Match.......: " << foundDNA << "\n";
		
		stringMatch = true;
	}
	
	return stringMatch;
}

/*
	Name.........: Generate Dental 
	Author.......: Michael Rouse
	Syntax.......: generateDental(DENTAL_SIZE);
	Parameters...: DENTAL_SIZE - the size of the ntca to return for the dental records 
	Return.......: The dental records generated 
	Description..: Will generate and return a character array of size DENTAL_SIZE representing the dental records
*/
void generateDental(char dental[], const int DENTAL_SIZE)
{
	// Constants for different type of teeth
	const double N_PERCENT = .50;
	const double W_PERCENT = .20;
	const double A_PERCENT = .15;
	const double G_PERCENT = .10;
	const double L_PERCENT = .05;

	const int N_MAX = getPercentage(DENTAL_SIZE, N_PERCENT); // ~50% of the teeth 
	const int W_MAX = getPercentage(DENTAL_SIZE, W_PERCENT); // ~20% of the teeth 
	const int A_MAX = getPercentage(DENTAL_SIZE, A_PERCENT); // ~15% of the teeth
	const int G_MAX = getPercentage(DENTAL_SIZE, G_PERCENT); // ~10% of the teeth
	const int L_MAX = getPercentage(DENTAL_SIZE, L_PERCENT); // ~05% of the teeth
	
	// This is the only way this function works properly???
	strcpy(dental, "");
	
	bool valid = false;
	int number;
	
	// Strand counters and array of possible strands
	// [0][0] - N Count 				[0][1] - Max N				|	strands[0] - N
	// [1][0] - W Count					[1][1] - Mac W 				|	strands[1] - W
	// [2][0] - A Count 				[2][1] - Max A				|	strands[2] - A
	// [3][0] - G Count 				[3][1] - Max G				|	strands[3] - G
	// [4][0] - L Count	 				[4][1] - Max L 				|	strands[4] - L
	int teethCount[][2] = {{0, N_MAX}, {0, W_MAX}, {0, A_MAX}, {0, G_MAX}, {0, L_MAX}}; // {{type_count, type_limit}, ...}
	const char* teeth[] = {"N", "W", "A", "G", "L"}; // All possible teeth
	
	for (int i = 0; i < DENTAL_SIZE; i++)
	{
		valid = false;
		
		// Loop until a valid and a valid tooth type is generated
		do
		{
			// Generate a random tooth
			number = random(0, 4);
			
			// Check to see if the strand has not reached it's limit; place it if it hasn't
			if (teethCount[number][0] < teethCount[number][1])
			{
				// I'm not sure why, but on this function for it to work I had to use strcat... Not sure why
				strcat(dental, teeth[number]);
				teethCount[number][0] += 1;
				valid = true;
			}
			
		}while (!valid);
	}
	
	// Set the null-terminating character
	dental[DENTAL_SIZE] = '\0';

	return;
}

/*
	Name.........: Check Dental Match 
	Author.......: Michael Rouse
	Syntax.......: checkDentalMatch(missingDental[], foundDental[], cowName);
	Parameters...: missingDental[] - the char array of the recorded cow dental record 
								 foundDental[] - the char array of the dead cow's dental records 
								 cowName - the string of the cow's name 
	Return.......: N/A
	Description..: Will check to see if the missingDental[] matches with foundDental[]
*/
bool checkDentalMatch(char missingDental[], char foundDental[], string cowName)
{	
	bool returnValue = false;
	
	cout << "\n\n";
	cout << "|===================================|\n";
	cout << "|            TEST 2 RESULTS         |\n";
	cout << "|===================================|\n";
	if (!strcmp(missingDental, foundDental))
	{
		// Match found
		cout << "Result......: Match Found!\n";
		cout << "Cow Name....: " << cowName << "\n";
		cout << "Accuracy....: 100%\n";
		cout << "Dental......: " << missingDental << "\n";
		cout << "Match.......: " << foundDental << "\n";

		returnValue = true;
	}else{
		// NO match
		cout << "Result......: Match Not Found! :(\n";
		cout << "Cow Name....: " << cowName << "\n";
		cout << "Dental......: " << missingDental << "\n";
	}
	
	return returnValue;
}

/*
	Name.........: Get Percentage
	Author.......: Michael Rouse
	Syntax.......: getPercentage(NUM, PER);
	Parameters...: NUM - the number you want to find the percentage for 
								 PER - the percentage you want to find 
	Return.......: The % of a number
	Description..: Will calculate a percentage of a number
*/
int getPercentage(const int NUM, const double PER)
{	
	return static_cast<int>((static_cast<double>(NUM) * PER) + 0.5);
}